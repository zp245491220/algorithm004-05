# 动态规划

递归是分治和动态规划的基础。分治与动态规划也没有本质上的区别，动态规划的难点在于寻找 DP 方程。从一个简单的 `Fib` 数列的写法上来看看那些不同。



### 1. 傻递归的写法



```
function fib(int n) {
    if (n <= 1) return n;
    return f(n-1) + f(n-2);
}
```



这个傻递归的时间复杂度为 `2^n` 。为什么看一下递归树状态



![F(6).png](https://cdn.nlark.com/yuque/0/2019/png/594932/1573606812854-38acf3e4-b7d4-4ebb-8a1e-f760fe56f0b5.png)



可以看到这里有大量重复的计算。如果我们将中间状态保存起来就可以节省大量的时间。看一下优化后的递归写法



### 2. 优化后的递归写法 == DP 自上而下的写法



```
function fib (int n,int[]opt) {
    if (n <= 1) {
        return n;
    }
    
    if(opt[n] == 0){
        opt[n] = fib(n-1,opt) + fib(n-2,opt);
    }
    
    return opt[n];
    
}
```



优化后递归记录了中间的计算值，大大减少了重复性计算，变成如下的计算树



![F(7).png](https://cdn.nlark.com/yuque/0/2019/png/594932/1573608798315-50838efb-b72a-4a34-abc5-f01ca19b65bb.png)



### 3. DP 的终极形态--DP方程

上面的写法都是递归的形式来写。从上面优化后的递归结构我们看到，如果计算 `fib(n)` 那就从底部向上推就好了。可以总结 DP 的方程式为 `opt[n] = opt[n-1] + opt[n-2]` ，注意这里是数组关系并不是递归函数。因此做一个循环就可以计算出。



```
function fib(n) {
    if (n <= 1) return n;
    int a[] = new int[n];
    a[0] = 0;
    a[1] = 1;
    for (int i = 2;i<n;i++) {
        a[i] = a[i-1] + a[i-2];
    }
    return a[i];
}
```

### 总结 DP 的步骤
* 分治找子问题
* 定义状态
* 推导 DP 方程

这些步骤中，第 2 步确实是最难的，我在做题的时候基本可以找到子问题，或者找到与Fib或者二维路径相似的问题，但是自己很难推导到公式。即使推导出公式，也需要自己在纸上对二维的 DP Table 边界进行处理。


